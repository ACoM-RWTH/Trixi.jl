
# The code contained in this file is generated by SnoopCompile.jl
# - except _precompile_manual_.
import StaticArrays

const __bodyfunction__ = Dict{Method,Any}()

# Find keyword "body functions" (the function that contains the body
# as written by the developer, called after all missing keyword-arguments
# have been assigned values), in a manner that doesn't depend on
# gensymmed names.
# `mnokw` is the method that gets called when you invoke it without
# supplying any keywords.
function __lookup_kwbody__(mnokw::Method)
  function getsym(arg)
    isa(arg, Symbol) && return arg
    @assert isa(arg, GlobalRef)
    return arg.name
  end

  f = get(__bodyfunction__, mnokw, nothing)
  if f === nothing
    fmod = mnokw.module
    # The lowered code for `mnokw` should look like
    #   %1 = mkw(kwvalues..., #self#, args...)
    #        return %1
    # where `mkw` is the name of the "active" keyword body-function.
    ast = Base.uncompressed_ast(mnokw)
    if isa(ast, Core.CodeInfo) && length(ast.code) >= 2
      callexpr = ast.code[end-1]
      if isa(callexpr, Expr) && callexpr.head == :call
        fsym = callexpr.args[1]
        if isa(fsym, Symbol)
          f = getfield(fmod, fsym)
        elseif isa(fsym, GlobalRef)
          if fsym.mod === Core && fsym.name === :_apply
            f = getfield(mnokw.module, getsym(callexpr.args[2]))
          elseif fsym.mod === Core && fsym.name === :_apply_iterate
            f = getfield(mnokw.module, getsym(callexpr.args[3]))
          else
            f = getfield(fsym.mod, fsym.name)
          end
        else
          f = missing
        end
      else
        f = missing
      end
    else
      f = missing
    end
    __bodyfunction__[mnokw] = f
  end
  return f
end


# manually generated precompile statements
function _precompile_manual_()
  ccall(:jl_generating_output, Cint, ()) == 1 || return nothing

  function equations_types_1d(RealT)
    ( LinearScalarAdvectionEquation1D{RealT},
      CompressibleEulerEquations1D{RealT},
    )
  end
  function equations_types_2d(RealT)
    ( LinearScalarAdvectionEquation2D{RealT},
      HyperbolicDiffusionEquations2D{RealT},
      CompressibleEulerEquations2D{RealT},
      IdealGlmMhdEquations2D{RealT},
    )
  end
  function equations_types_3d(RealT)
    ( LinearScalarAdvectionEquation3D{RealT},
      HyperbolicDiffusionEquations3D{RealT},
      CompressibleEulerEquations3D{RealT},
      IdealGlmMhdEquations3D{RealT},
    )
  end
  function equations_types(RealT)
    ( LinearScalarAdvectionEquation1D{RealT},
      LinearScalarAdvectionEquation2D{RealT},
      LinearScalarAdvectionEquation3D{RealT},
      HyperbolicDiffusionEquations2D{RealT},
      HyperbolicDiffusionEquations3D{RealT},
      CompressibleEulerEquations1D{RealT},
      CompressibleEulerEquations2D{RealT},
      CompressibleEulerEquations3D{RealT},
      IdealGlmMhdEquations2D{RealT},
      IdealGlmMhdEquations3D{RealT},
    )
  end

  # Constructors: mesh
  for RealT in (Int, Float64,)
    @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:initial_refinement_level, :n_cells_max),Tuple{Int,Int}},Type{TreeMesh},RealT,RealT})
    @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:initial_refinement_level, :n_cells_max),Tuple{Int,Int}},Type{TreeMesh},Tuple{RealT},Tuple{RealT}})
    @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:initial_refinement_level, :n_cells_max),Tuple{Int,Int}},Type{TreeMesh},Tuple{RealT,RealT},Tuple{RealT,RealT}})
    @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:initial_refinement_level, :n_cells_max),Tuple{Int,Int}},Type{TreeMesh},Tuple{RealT,RealT,RealT},Tuple{RealT,RealT,RealT}})
  end

  # Constructors: linear advection
  for RealT in (Float64,)
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation1D},RealT})
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation2D},RealT,RealT})
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation2D},Tuple{RealT,RealT}})
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation3D},RealT,RealT,RealT})
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation3D},Tuple{RealT,RealT,RealT}})
  end

  # Constructors: hyperbolic diffusion
  for RealT in (Float64,)
    @assert Base.precompile(Tuple{Type{HyperbolicDiffusionEquations2D},RealT})
    @assert Base.precompile(Tuple{Type{HyperbolicDiffusionEquations3D},RealT})
  end

  # Constructors: Euler
  for RealT in (Float64,)
    @assert Base.precompile(Tuple{Type{CompressibleEulerEquations1D},RealT})
    @assert Base.precompile(Tuple{Type{CompressibleEulerEquations2D},RealT})
    @assert Base.precompile(Tuple{Type{CompressibleEulerEquations3D},RealT})
  end

  # Constructors: MHD
  for RealT in (Float64,)
    @assert Base.precompile(Tuple{Type{IdealGlmMhdEquations2D},RealT})
    @assert Base.precompile(Tuple{Type{IdealGlmMhdEquations3D},RealT})
  end

  # Constructors of the basis are inherently not type-stable since we pass integers
  # and use their values as parameters of static arrays.
  # Nevertheless, we can still precompile methods used to construct the bases.
  for RealT in (Float64,)
    @assert Base.precompile(Tuple{typeof(Trixi.calc_dhat),Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.calc_dsplit),Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.polynomial_derivative_matrix),Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.polynomial_interpolation_matrix),Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.barycentric_weights),Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.calc_lhat),RealT,Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.lagrange_interpolating_polynomials),RealT,Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.calc_q_and_l),Int,RealT})
    @assert Base.precompile(Tuple{typeof(Trixi.legendre_polynomial_and_derivative),Int,RealT})
    @assert Base.precompile(Tuple{typeof(Trixi.vandermonde_legendre),Vector{RealT}})
  end
  @assert Base.precompile(Tuple{typeof(Trixi.gauss_lobatto_nodes_weights),Int})
  @assert Base.precompile(Tuple{typeof(Trixi.gauss_nodes_weights),Int})

  # Constructors: mortars, analyzers, adaptors
  for RealT in (Float64,), polydeg in 1:7
    nnodes_ = polydeg + 1
    basis_type = LobattoLegendreBasis{RealT,nnodes_,Array{RealT,2},StaticArrays.SArray{Tuple{nnodes_,2},RealT,2,2*nnodes_},StaticArrays.SArray{Tuple{nnodes_,nnodes_},RealT,2,nnodes_^2}}
    @assert Base.precompile(Tuple{typeof(Trixi.MortarL2),basis_type})
    @assert Base.precompile(Tuple{Type{Trixi.SolutionAnalyzer},basis_type})
    @assert Base.precompile(Tuple{Type{Trixi.AdaptorL2},basis_type})
  end

  # Constructors: callbacks
  @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:analysis_interval,),Tuple{Int}},Type{AliveCallback}})
  for RealT in (Float64,)
    @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:cfl,),Tuple{RealT}},Type{StepsizeCallback}})
  end
  @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:interval, :save_final_restart),Tuple{Int,Bool}},Type{SaveRestartCallback}})
  @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:interval, :save_initial_solution, :save_final_solution, :solution_variables),Tuple{Int,Bool,Bool,Symbol}},Type{SaveSolutionCallback}})
  for RealT in (Float64,), polydeg in 1:7
    nnodes_ = polydeg + 1
    nnodes_analysis = 2*polydeg + 1
    @assert Base.precompile(Tuple{Type{AnalysisCallback},RealT,Int,Bool,String,String,Trixi.LobattoLegendreAnalyzer{RealT,nnodes_analysis,Array{RealT,2}},Array{Symbol,1},Tuple{typeof(Trixi.entropy_timederivative),typeof(entropy)},StaticArrays.SArray{Tuple{1},RealT,1,1}})
    # We would need to use all special cases instead of
    # Function,Trixi.AbstractVolumeIntegral
    # for equations_type in equations_types(RealT)
    #   @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:interval, :extra_analysis_integrals),Tuple{Int,Tuple{typeof(entropy)}}},Type{AnalysisCallback},equations_type,DG{RealT,LobattoLegendreBasis{RealT,nnodes_,Array{RealT,2},StaticArrays.SArray{Tuple{4,2},RealT,2,2*nnodes_},StaticArrays.SArray{Tuple{nnodes_,nnodes_},RealT,2,nnodes_^2}},Trixi.LobattoLegendreMortarL2{RealT,nnodes_,StaticArrays.SArray{Tuple{nnodes_,nnodes_},RealT,2,nnodes_^2}},Function,Trixi.AbstractVolumeIntegral}})
    # end
  end
  Base.precompile(Tuple{typeof(SummaryCallback)})
  # TODO: AMRCallback, ControllerThreeLevel, indicators

  # init_elements, interfaces, etc.
  for RealT in (Float64,), polydeg in 1:7
    nnodes_ = polydeg + 1

    # 2D, serial
    Base.precompile(Tuple{typeof(Trixi.init_boundaries),Array{Int,1},TreeMesh{1,Trixi.SerialTree{1}},Trixi.ElementContainer1D{RealT,1,polydeg}})
    Base.precompile(Tuple{typeof(Trixi.init_interfaces),Array{Int,1},TreeMesh{1,Trixi.SerialTree{1}},Trixi.ElementContainer1D{RealT,1,polydeg}})

    # 2D, serial
    Base.precompile(Tuple{typeof(Trixi.init_boundaries),Array{Int,1},TreeMesh{2,Trixi.SerialTree{2}},Trixi.ElementContainer2D{RealT,1,polydeg}})
    Base.precompile(Tuple{typeof(Trixi.init_interfaces),Array{Int,1},TreeMesh{2,Trixi.SerialTree{2}},Trixi.ElementContainer2D{RealT,1,polydeg}})
    Base.precompile(Tuple{typeof(Trixi.init_mortars),Array{Int,1},TreeMesh{2,Trixi.SerialTree{2}},Trixi.ElementContainer2D{RealT,1,polydeg},Trixi.LobattoLegendreMortarL2{RealT,nnodes_,StaticArrays.SArray{Tuple{nnodes_,nnodes_},RealT,2,nnodes_^2}}})

    # TODO: 2D, parallel

    # 3D, serial
    Base.precompile(Tuple{typeof(Trixi.init_boundaries),Array{Int,1},TreeMesh{3,Trixi.SerialTree{3}},Trixi.ElementContainer3D{RealT,1,polydeg}})
    Base.precompile(Tuple{typeof(Trixi.init_interfaces),Array{Int,1},TreeMesh{3,Trixi.SerialTree{3}},Trixi.ElementContainer3D{RealT,1,polydeg}})
    Base.precompile(Tuple{typeof(Trixi.init_mortars),Array{Int,1},TreeMesh{3,Trixi.SerialTree{3}},Trixi.ElementContainer3D{RealT,1,polydeg},Trixi.LobattoLegendreMortarL2{RealT,nnodes_,StaticArrays.SArray{Tuple{nnodes_,nnodes_},RealT,2,nnodes_^2}}})
  end
end

