
# The code contained in this file is generated by SnoopCompile.jl
# - except _precompile_manual_.
import StaticArrays

const __bodyfunction__ = Dict{Method,Any}()

# Find keyword "body functions" (the function that contains the body
# as written by the developer, called after all missing keyword-arguments
# have been assigned values), in a manner that doesn't depend on
# gensymmed names.
# `mnokw` is the method that gets called when you invoke it without
# supplying any keywords.
function __lookup_kwbody__(mnokw::Method)
  function getsym(arg)
    isa(arg, Symbol) && return arg
    @assert isa(arg, GlobalRef)
    return arg.name
  end

  f = get(__bodyfunction__, mnokw, nothing)
  if f === nothing
    fmod = mnokw.module
    # The lowered code for `mnokw` should look like
    #   %1 = mkw(kwvalues..., #self#, args...)
    #        return %1
    # where `mkw` is the name of the "active" keyword body-function.
    ast = Base.uncompressed_ast(mnokw)
    if isa(ast, Core.CodeInfo) && length(ast.code) >= 2
      callexpr = ast.code[end-1]
      if isa(callexpr, Expr) && callexpr.head == :call
        fsym = callexpr.args[1]
        if isa(fsym, Symbol)
          f = getfield(fmod, fsym)
        elseif isa(fsym, GlobalRef)
          if fsym.mod === Core && fsym.name === :_apply
            f = getfield(mnokw.module, getsym(callexpr.args[2]))
          elseif fsym.mod === Core && fsym.name === :_apply_iterate
            f = getfield(mnokw.module, getsym(callexpr.args[3]))
          else
            f = getfield(fsym.mod, fsym.name)
          end
        else
          f = missing
        end
      else
        f = missing
      end
    else
      f = missing
    end
    __bodyfunction__[mnokw] = f
  end
  return f
end


# manually generated precompile statements
function _precompile_manual_()
  ccall(:jl_generating_output, Cint, ()) == 1 || return nothing

  # Constructors: mesh
  for RealT in (Int, Float64,)
    @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:initial_refinement_level, :n_cells_max),Tuple{Int,Int}},Type{TreeMesh},RealT,RealT})
    @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:initial_refinement_level, :n_cells_max),Tuple{Int,Int}},Type{TreeMesh},Tuple{RealT},Tuple{RealT}})
    @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:initial_refinement_level, :n_cells_max),Tuple{Int,Int}},Type{TreeMesh},Tuple{RealT,RealT},Tuple{RealT,RealT}})
    @assert Base.precompile(Tuple{Core.kwftype(typeof(Trixi.Type)),NamedTuple{(:initial_refinement_level, :n_cells_max),Tuple{Int,Int}},Type{TreeMesh},Tuple{RealT,RealT,RealT},Tuple{RealT,RealT,RealT}})
  end

  # Constructors: linear advection
  for RealT in (Float64,)
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation1D},RealT})
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation2D},RealT,RealT})
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation2D},Tuple{RealT,RealT}})
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation3D},RealT,RealT,RealT})
    @assert Base.precompile(Tuple{Type{LinearScalarAdvectionEquation3D},Tuple{RealT,RealT,RealT}})
  end

  # Constructors of the basis are inherently not type-stable since we pass integers
  # and use their values as parameters of static arrays.
  # Nevertheless, we can still precompile methods used to construct the bases.
  for RealT in (Float64,)
    @assert Base.precompile(Tuple{typeof(Trixi.calc_dhat),Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.calc_dsplit),Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.polynomial_derivative_matrix),Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.polynomial_interpolation_matrix),Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.barycentric_weights),Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.calc_lhat),RealT,Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.lagrange_interpolating_polynomials),RealT,Vector{RealT},Vector{RealT}})
    @assert Base.precompile(Tuple{typeof(Trixi.calc_q_and_l),Int,RealT})
    @assert Base.precompile(Tuple{typeof(Trixi.legendre_polynomial_and_derivative),Int,RealT})
    @assert Base.precompile(Tuple{typeof(Trixi.vandermonde_legendre),Vector{RealT}})
  end
  @assert Base.precompile(Tuple{typeof(Trixi.gauss_lobatto_nodes_weights),Int})
  @assert Base.precompile(Tuple{typeof(Trixi.gauss_nodes_weights),Int})

  # Constructors: mortars, analyzers, adaptors
  for RealT in (Float64,), polydeg in 1:7
    nnodes_ = polydeg + 1
    basis_type = LobattoLegendreBasis{RealT,nnodes_,Array{RealT,2},StaticArrays.SArray{Tuple{nnodes_,2},RealT,2,2*nnodes_},StaticArrays.SArray{Tuple{nnodes_,nnodes_},RealT,2,nnodes_^2}}
    @assert Base.precompile(Tuple{typeof(Trixi.MortarL2),basis_type})
    @assert Base.precompile(Tuple{Type{Trixi.SolutionAnalyzer},basis_type})
    @assert Base.precompile(Tuple{Type{Trixi.AdaptorL2},basis_type})
  end
end

